{"name":"Conformist","body":"# Conformist\r\n\r\n[![Build Status](https://secure.travis-ci.org/tatey/conformist.png)](http://travis-ci.org/tatey/conformist)\r\n\r\nBend CSVs to your will with declarative schemas. Map one or many columns, preprocess cells and lazily enumerate. Declarative schemas are easier to understand, quicker to setup and independent of I/O. Use [CSV](http://www.ruby-doc.org/stdlib-1.9.3/libdoc/csv/rdoc/CSV.html) (Formally [FasterCSV](https://rubygems.org/gems/fastercsv)), [Spreadsheet](https://rubygems.org/gems/spreadsheet) or any array of array-like data structure.\r\n\r\n![](http://f.cl.ly/items/00191n3O1J2E1a342F1L/conformist.jpg)\r\n\r\n## Quick and Dirty Examples\r\n\r\nOpen a CSV file and declare a schema. A schema compromises of columns. A column takes an arbitary name followed by its position in the input. A column may be derived from multiple positions.\r\n\r\n``` ruby\r\nrequire 'conformist'\r\nrequire 'csv'\r\n\r\ncsv    = CSV.open '~/transmitters.csv'\r\nschema = Conformist.new do\r\n  column :callsign, 1\r\n  column :latitude, 1, 2, 3\r\n  column :longitude, 3, 4, 5\r\n  column :name, 0 do |value|\r\n    value.upcase\r\n  end\r\nend\r\n```\r\n\r\nInsert the transmitters into a SQLite database.\r\n\r\n``` ruby\r\nrequire 'sqlite3'\r\n\r\ndb = SQLite3::Database.new 'transmitters.db'\r\nschema.conform(csv).each do |transmitter|\r\n  db.execute \"INSERT INTO transmitters (callsign, ...) VALUES ('#{transmitter.callsign}', ...);\"\r\nend\r\n```\r\n\r\nOnly insert the transmitters with the name \"Mount Cooth-tha\" using ActiveRecord or DataMapper.\r\n\r\n``` ruby\r\ntransmitters = schema.conform(csv).select do |transmitter|\r\n  transmitter.name == 'Mount Coot-tha'\r\nend\r\ntransmitter.each do |transmitter|\r\n  Transmitter.create! transmitter.attributes\r\nend\r\n```\r\n\r\nSource from multiple, different input files and insert transmitters together into a single database.\r\n\r\n``` ruby\r\nrequire 'conformist'\r\nrequire 'csv'\r\nrequire 'sqlite3'\r\n\r\nau_schema = Conformist.new do\r\n  column :callsign, 8\r\n  column :latitude, 10\r\nend\r\nus_schema = Conformist.new do\r\n  column :callsign, 1\r\n  column :latitude, 1, 2, 3\r\nend\r\n\r\nau_csv = CSV.open '~/au/transmitters.csv'\r\nus_csv = CSV.open '~/us/transmitters.csv'\r\n\r\ndb = SQLite3::Database.new 'transmitters.db'\r\n\r\n[au_schema.conform(au_csv), us_schema.conform(us_csv)].each do |schema|\r\n  schema.each do |transmitter|\r\n    db.execute \"INSERT INTO transmitters (callsign, ...) VALUES ('#{transmitter.callsign}', ...);\"\r\n  end\r\nend\r\n```\r\n\r\nOpen a Microsoft Excel spreadsheet and declare a schema.\r\n\r\n``` ruby\r\nrequire 'conformist'\r\nrequire 'spreadsheet'\r\n\r\nbook   = Spreadsheet.open '~/states.xls'\r\nsheet  = book.worksheet 0\r\nschema = Conformist.new do\r\n  column :state, 0, 1 do |values|\r\n    \"#{values.first}, #{values.last}\"\r\n  end\r\n  column :capital, 2\r\nend\r\n```\r\n\r\nPrint each state's attributes to standard out.\r\n\r\n``` ruby\r\nschema.conform(sheet).each do |state|\r\n  $stdout.puts state.attributes\r\nend\r\n```\r\n\r\nFor more examples see [test/fixtures](https://github.com/tatey/conformist/tree/master/test/fixtures), [test/schemas](https://github.com/tatey/conformist/tree/master/test/schemas) and [test/unit/integration_test.rb](https://github.com/tatey/conformist/blob/master/test/unit/integration_test.rb).\r\n\r\n## Installation\r\n\r\nConformist is available as a gem. Install it at the command line.\r\n\r\n``` sh\r\n$ [sudo] gem install conformist\r\n```\r\n\r\nOr add it to your Gemfile and run `$ bundle install`.\r\n\r\n``` ruby\r\ngem 'conformist'\r\n```\r\n\r\n## Usage\r\n\r\n### Anonymous Schema\r\n\r\nAnonymous schemas are quick to declare and don't have the overhead of creating an explicit class.\r\n\r\n``` ruby\r\ncitizen = Conformist.new do\r\n  column :name, 0, 1\r\n  column :email, 2\r\nend\r\n\r\ncitizen.conform [['Tate', 'Johnson', 'tate@tatey.com']]\r\n```\r\n\r\n### Class Schema\r\n\r\nClass schemas are explicit. Class schemas were the only type available in earlier versions of Conformist.\r\n\r\n``` ruby\r\nclass Citizen\r\n  extend Conformist\r\n\r\n  column :name, 0, 1\r\n  column :email, 2\r\nend\r\n\r\nCitizen.conform [['Tate', 'Johnson', 'tate@tatey.com']]\r\n```\r\n\r\n### Implicit Indexing\r\n\r\nColumn indexes are implicitly incremented when the index argument is omitted. Implicit indexing is all or nothing.\r\n\r\n``` ruby\r\ncolumn :account_number                              # => 0\r\ncolumn :date { |v| Time.new *v.split('/').reverse } # => 1\r\ncolumn :description                                 # => 2\r\ncolumn :debit                                       # => 3\r\ncolumn :credit                                      # => 4\r\n```\r\n\r\n### Conform\r\n\r\nConform is the principle method for lazily applying a schema to the given input.\r\n\r\n``` ruby\r\nenumerator = schema.conform CSV.open('~/file.csv')\r\nenumerator.each do |row|\r\n  puts row.attributes\r\nend\r\n```\r\n\r\n#### Input\r\n\r\n`#conform` expects any object that responds to `#each` to return an array-like object.\r\n\r\n``` ruby\r\nCSV.open('~/file.csv').responds_to? :each # => true\r\n[[], [], []].responds_to? :each           # => true\r\n```\r\n\r\n#### Enumerator\r\n\r\n`#conform` is lazy, returning an [Enumerator](http://www.ruby-doc.org/core-1.9.3/Enumerator.html). Input is not parsed until you call `#each`, `#map` or any method defined in [Enumerable](http://www.ruby-doc.org/core-1.9.3/Enumerable.html). That means schemas can be assigned now and evaluated later. `#each` has the lowest memory footprint because it does not build a collection.\r\n\r\n#### Struct\r\n\r\nThe argument passed into the block is a struct-like object. You can access columns as methods or keys. Columns were only accessible as keys in earlier versions of Conformist. Methods are now the preferred syntax.\r\n\r\n``` ruby\r\ncitizen[:name] # => \"Tate Johnson\"\r\ncitizen.name   # => \"Tate Johnson\"\r\n```\r\n\r\nFor convenience the `#attributes` method returns a hash of key-value pairs suitable for creating ActiveRecord or DataMapper records.\r\n\r\n``` ruby\r\ncitizen.attributes # => {:name => \"Tate Johnson\", :email => \"tate@tatey.com\"}\r\n```\r\n\r\n### One Column\r\n\r\nMaps the first column in the input file to `:first_name`. Column indexing starts at zero.\r\n\r\n``` ruby\r\ncolumn :first_name, 0\r\n```\r\n\r\n### Many Columns\r\n\r\nMaps the first and second columns in the input file to `:name`.\r\n\r\n``` ruby\r\ncolumn :name, 0, 1\r\n```\r\n\r\nIndexing is completely arbitrary and you can map any combination.\r\n\r\n``` ruby\r\ncolumn :name_and_city 0, 1, 2\r\n```\r\n\r\nMany columns are implicitly concatenated. Behaviour can be changed by passing a block. See *preprocessing*.\r\n\r\n### Preprocessing\r\n\r\nSometimes values need to be manipulated before they're conformed. Passing a block gets access to values. The return value of the block becomes the conformed output.\r\n\r\n``` ruby\r\ncolumn :name, 0, 1 do |values|\r\n  values.map(&:upcase) * ' '\r\nend\r\n```\r\n\r\nWorks with one column too. Instead of getting a collection of objects, one object is passed to the block.\r\n\r\n``` ruby\r\ncolumn :first_name, 0 do |value|\r\n  value.upcase\r\nend\r\n```\r\n\r\n### Virtual Columns\r\n\r\nVirtual columns are not sourced from input. Omit the index to create a virtual column. Like real columns, virtual columns are included in the conformed output.\r\n\r\n``` ruby\r\ncolumn :day do\r\n  1\r\nend\r\n```\r\n\r\n### Inheritance\r\n\r\nInheriting from a schema gives access to all of the parent schema's columns.\r\n\r\n#### Anonymous Schema\r\n\r\nAnonymous inheritance takes inspiration from Ruby's syntax for [instantiating new classes](http://ruby-doc.org/core-1.9.3/Class.html#method-c-new).\r\n\r\n``` ruby\r\nparent = Conformist.new do\r\n  column :name, 0, 1\r\nend\r\n\r\nchild = Conformist.new parent do\r\n  column :category do\r\n    'Child'\r\n  end\r\nend\r\n```\r\n\r\n#### Class Schema\r\n\r\nClassical inheritance works as expected.\r\n\r\n``` ruby\r\nclass Parent\r\n  extend Conformist\r\n\r\n  column :name, 0, 1\r\nend\r\n\r\nclass Child < Parent\r\n  column :category do\r\n    'Child'\r\n  end\r\nend\r\n```\r\n\r\n## Upgrading from <= 0.0.3 to >= 0.1.0\r\n\r\nWhere previously you had\r\n\r\n``` ruby\r\nclass Citizen\r\n  include Conformist::Base\r\n\r\n  column :name, 0, 1\r\nend\r\n\r\nCitizen.load('~/file.csv').foreach do |citizen|\r\n  # ...\r\nend\r\n```\r\n\r\nYou should now do\r\n\r\n``` ruby\r\nrequire 'fastercsv'\r\n\r\nclass Citizen\r\n  extend Conformist\r\n\r\n  column :name, 0, 1\r\nend\r\n\r\nCitizen.conform(FasterCSV.open('~/file.csv')).each do |citizen|\r\n  # ...\r\nend\r\n```\r\n\r\nSee CHANGELOG.md for a full list of changes.\r\n\r\n## Compatibility\r\n\r\n* MRI 1.9.2+\r\n* MRI 1.8.7\r\n* JRuby 1.6.5\r\n\r\n## Dependancies\r\n\r\nNo explicit dependencies, although `CSV` and `Spreadsheet` are commonly used.\r\n\r\n## Contributing\r\n\r\n1. Fork\r\n2. Install dependancies by running `$ bundle install`\r\n3. Write tests and code\r\n4. Make sure the tests pass by running `$ bundle exec rake`\r\n5. Push and send a pull request on GitHub\r\n\r\n## Motivation\r\n\r\nMotivation for this project came from the desire to simplify importing data from various government organisations into [Antenna Mate](http://antennamate.com). The data from each government was similar, but had completely different formatting. Some pieces of data needed preprocessing while others simply needed to be concatenated together. Not wanting to write a parser for each new government organisation, I created Conformist.\r\n\r\n## Copyright\r\n\r\nCopyright Â© 2011 Tate Johnson. Conformist is released under the MIT license. See LICENSE for details.","tagline":"Bend CSVs to your will with declarative schemas.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}